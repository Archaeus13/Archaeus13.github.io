## 选择

- 以下指令中与其他三个类型不同的是（A）。

        A. lui
        B. jalr
        C. lh
        D. ebreak

- 以下指令属于RV32I的是（B）。

        A. mul
        B. sra
        C. flw
        D. ld

## 填空

- 16位有符号二进制数所能表示的最大整数为（用16进制写出）$\text{0x}\underline{\text{7FFF}}$。

- 在以下指令执行后，寄存器x5的值是 $\underline{-201(\text{0xFFFFFF37})}$，寄存器x6的值是 $\underline{190(\text{0x0BE})}$。

        addi x5, x0, 190
        addi x6, x0, -201
        xor x5, x5, x6
        xor x6, x5, x6
        xor x5, x5, x6

- 在RV32I中，加载任意位数立即数的伪指令li是通过指令 $\underline{\text{lui}}$ 与指令 $\underline{\text{addi}}$  实现的。

- 在RV32I中，实现 x1 = \~x1，其中\~表示按位取反，只需要一条 $\underline{\text{xori}}$ 指令。

## 简答

- 已知两个64位有符号二进制数a与b，a的高32位、低32位保存在寄存器x1、x2中，b的高32位、低32位保存在寄存器x3、x4中，请写出RV32I指令集下的汇编代码，计算a-b，将其高32位、低32位保存在寄存器x5、x6中（不考虑溢出，其他寄存器可任意使用，标签可任意使用）。

    - 解答：

            sub x5, x1, x3
            sub x6, x2, x4
            bgeu x2, x4, END
            addi x5, x5, -1
            END: nop

    - 共5分，建议标准为：
        - 能够正确计算无借位的减法 2'
        - 能够正确计算有借位的减法 3'
        - 若有明显书写错误（如写出subi） 扣除 1'

- （实验题）小明在进行CPU设计的过程中，需要设计一个支持加减运算的算术逻辑单元（ALU）模块。为了偷懒，他决定将beq指令也放入ALU中判断，因此增添了结果是否为0的标志位。于是，他写出了如下的代码：

        module ALU (
            input [31:0] a,     	// 操作数1
            input [31:0] b,     	// 操作数2
            input [2:0] f,      	// ALU控制信号
            output reg [31:0] y,	// 结果
            output z        		// 标致结果是否为0
        );
        always @(*) begin
                if f == 0 begin 	// f = 0 表示加法
                    y = a + b;
                end
            end
            always @(*) begin
                if f == 1 begin 	// f = 1 表示减法
                    y = a - b;
                end
            end
        assign z = (y == 0);
        endmodule

    在实践中，小明发现，这段代码可以正常进行仿真，但烧写后却经常发生时序问题，请分析可能的原因并给出解决方案。

    - 解答：

        主要问题为：两个if块中对同一变量赋值引起的多驱动与没有默认赋值引起的锁存器。可将代码改为

            always @(*) begin
                y = 0
                case(f)
                    0: y = a + b // f = 0 表示加法
                    1: y = a - b // f = 1 表示减法
                endcase
                z = (y == 0)
            end

    - 共5分，建议标准为：
        - 有字 1'
        - 答到多驱动或multi-driven net 1'
        - 解决多驱动 1'
        - 答到生成锁存器、寄存器或latch 1'
        - 解决锁存器 1'
        
        （即使没有正确分析原因，如果在解决方案中写出了正确的代码，也可以获得解决的分数）

## 大题

（共15分）

**本题中的代码均在RV32I指令集讨论。**

我们在数据结构中学过，一个**队列**是指能做到先入先出的数据结构，具体来说，它只能在队头进行删除操作，在队尾进行插入操作。以下代码中除 x5 到 x9 与 x31 外的寄存器可任意使用。

1. 考虑一个存储器中的队列，每个元素是**32位**的int型。队头地址、队尾地址分别保存在寄存器 x5、x6 中，定义 ENQUEUE 操作代表将寄存器 x7 中的值插入到队尾， DEQUEUE 操作代表将队头出队并将值保存在寄存器 x7 中，请填空以完成代码，其中 x8 标志着操作的状态。（4分）

        addi x5, x0, 0  # 初始化队头
        addi x6, x0, 0  # 初始化队尾
        addi x7, x0, 2
        jal ENQUEUE     # 2 入队
        addi x7, x0, -1
        jal ENQUEUE     # -1 入队
        jal DEQUEUE     # 2 出队
        jal DEQUEUE     # -1 出队
        j END
    
        ENQUEUE:
        addi x8, x0, 0  # 入队开始
        ____________
        ____________
        j FINISH
    
        DEQUEUE:
        addi x8, x0, 0  # 出队开始
        ____________
        ____________
        j FINISH
    
        FINISH:
        addi x8, x0, 1  # 操作完成
        ret
    
        END: nop

2. 由于数据储存器中数据范围有限，假设我们只允许利用 0x0000 到 0x1000 之间（包含开头不包含结尾）的地址空间，这里 0x1000 保存在寄存器 x31 中；当队列中并没有数据时，出队操作也将失败。请据此改写 ENQUEUE 与 DEQUEUE 操作，当入队失败时将 x8 的值设置成 -1。（两操作各1.5分）

        ENQUEUE:
        addi x8, x0, 0  # 入队开始
        # YOUR CODE HERE
    

        sw x7, 0(x6)
        addi x6, x6, 4
        j FINISH
    
        DEQUEUE:
        addi x8, x0, 0  # 出队开始
        # YOUR CODE HERE
    

        lw x7, 0(x5)
        addi x5, x5, 4
        j FINISH
    
        FINISH:
        addi x8, x0, 1  # 操作完成
        ret
    
        FAIL:
        addi x8, x0, -1 # 操作失败
        ret

3. 为了更充分地利用空间，我们采用**循环队列**的数据结构，也即当队尾将达到 0x1000 时，若 0x0000 处没有元素，入队操作将在 0x0000 进行，随后继续向后。此外，由于循环队列中仅通过队头、队尾的位置无法确定队满还是队空，我们额外应用寄存器 x9 ，其仅在队空时为 1（初始为1）。请据此改写 ENQUEUE 与 DEQUEUE 操作，使得队列成为循环队列。（两操作各3分）

### 解答

1. 
            addi x5, x0, 0  # 初始化队头
            addi x6, x0, 0  # 初始化队尾
            addi x7, x0, 2
            jal ENQUEUE     # 2 入队
            addi x7, x0, -1
            jal ENQUEUE     # -1 入队
            jal DEQUEUE     # 2 出队
            jal DEQUEUE     # -1 出队
            j END
    
            ENQUEUE:
            addi x8, x0, 0  # 入队开始
            sw x7, 0(x6)
            addi x6, x6, 4
            j FINISH
    
            DEQUEUE:
            addi x8, x0, 0  # 出队开始
            lw x7, 0(x5)
            addi x5, x5, 4
            j FINISH
    
            FINISH:
            addi x8, x0, 1  # 操作完成
            ret       
    
            END: nop

2. 
            ENQUEUE:
            addi x8, x0, 0  # 入队开始
            beq x6, x31, FAIL
            sw x7, 0(x6)
            addi x6, x6, 4
            j FINISH
    
            DEQUEUE:
            addi x8, x0, 0  # 出队开始
            beq x5, x6, FAIL
            lw x7, 0(x5)
            addi x5, x5, 4
            j FINISH
    
            FINISH:
            addi x8, x0, 1  # 操作完成
            ret   
    
            FAIL:
            addi x8, x0, -1 # 操作失败
            ret

3. 
            ENQUEUE:
            addi x8, x0, 0  # 入队开始
            blt x0, x9, NEXT
            beq x5, x6, FAIL
            NEXT:
            sw x7, 0(x6)
            addi x9, x0, 0
            addi x6, x6, 4
            blt x6, x31, FINISH
            addi x6, x0, 0
            j FINISH
    
            DEQUEUE:
            addi x8, x0, 0  # 出队开始
            blt x0, x9, FAIL
            lw x7, 0(x5)
            addi x5, x5, 4
            blt x5, x31, SET
            addi x5, x0, 0
            SET:
            bne x5, x6, FINISH
            addi x9, x0, 1
            j FINISH
    
            FINISH:
            addi x8, x0, 1  # 操作完成
            ret   
    
            FAIL:
            addi x8, x0, -1 # 操作失败
            ret